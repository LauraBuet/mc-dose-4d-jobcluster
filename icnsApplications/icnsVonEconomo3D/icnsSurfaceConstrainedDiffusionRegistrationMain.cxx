/** \file imiSurfaceConstrainedDiffusionMain.cpp
 *
 *  \b Initial \b Author: Jan Ehrhardt \n\n
 *  \b Copyright (C) 2010 Institute of Medical Informatics,
 *     University of Luebeck
 *
 *  <!----------------------------------------------------------------------->
 *  <!--  Version Information  (generated by CVS, do not change manually)  -->
 *  $Id$
 *  $Log$
 *  Revision 1.1.1.1  2010-07-05 11:45:12  aschmiri
 *  Initial checkin.
 *
 *
 ****************************************************************************/

extern "C"
{
#include "getopt.h"
}

#include <itkMultiThreader.h>

#include <vtkPolyDataReader.h>
#include <vtkCleanPolyData.h>
#include <vtkPolyDataWriter.h>
#include <vtkTransformPolyDataFilter.h>
#include <vtkIterativeClosestPointTransform.h>
#include <vtkLandmarkTransform.h>

#include "icnsSurfaceConstrainedDiffusionRegistrationFilter.h"
#include "icnsSymmetricSurfaceConstrainedDiffusionRegistrationFilter.h"

using namespace imi;

void PrintHelp()
{
  std::cout << "\n";
  std::cout << "Usage:\n";
  std::cout << "icnsSurfaceConstrainedDiffusion [Options] -R <reference> -T <target> -O <output>\n\n";
  std::cout << "Parameters:\n";
  std::cout << "-m                   Use symmetric smoothing.\n";
  std::cout << "-p                   Use pre-calculated neighborhood lists.\n";
  std::cout << "-i <iter>            Max. Iterations for Matching process.\n";
  std::cout << "-s <sigma>           Sigma for smoothing.\n";
  std::cout << "-q <threads>         Max. number of threads.\n";
  std::cout << "-d <level>           Debug-Level.\n";
  std::cout << "\n";

  exit(0);
}

int main(int argc, char *argv[])
{
  if( argc < 2 )
  {
    PrintHelp();
    return 1;
  }

  std::cout << "==========================================" << std::endl;
  std::cout << "====  imiSurfaceConstrainedDiffusion  ====" << std::endl;
  std::cout << "==========================================" << std::endl;
  std::cout << "READING parameters...\n" << std::endl;

  int c;
  int intVal;
  char *referenceFilename = NULL;
  char *targetFilename = NULL;
  char *outputFilename = NULL;

  bool bPreRegistration = true;
  int numberOfIterations = 10;
  double sigma = 2.0;
  bool bSymmetric = false;
  bool bPrecalculated = false;
  int maxNumberOfThreads = -1;

  while( (c = getopt(argc, argv, "R:T:O:mpi:s:q:")) != -1 )
  {
    switch (c)
    {
    case 'R':
      referenceFilename = optarg;
      std::cout << "  Reference surface filename: " << referenceFilename << std::endl;
      break;
    case 'T':
      targetFilename = optarg;
      std::cout << "  Target surface filename:    " << targetFilename << std::endl;
      break;
    case 'O':
      outputFilename = optarg;
      std::cout << "  Output surface filename:    " << outputFilename << std::endl;
      break;
    case 'm':
      bSymmetric = true;
      std::cout << "  Use symmetric matching:     true" << std::endl;
      break;
    case 'p':
      bPrecalculated = true;
      std::cout << "  Use precalc. neigh. list:   true" << std::endl;
      break;
    case 'i':
      numberOfIterations=atoi(optarg);
      std::cout << "  Iterations:                 " << numberOfIterations << std::endl;
      break;
    case 's':
      sigma = atof(optarg);
      std::cout << "  Sigma:                      " << sigma << std::endl;
      break;
    case 'q':
      maxNumberOfThreads = atoi( optarg );
      std::cout << "  Maximum number of threads:  " << maxNumberOfThreads << std::endl;
      break;
    }
  }

  if( referenceFilename == NULL || targetFilename == NULL )
    PrintHelp();

  vtkPolyDataReader *referenceReader = vtkPolyDataReader::New();
  referenceReader->SetFileName(referenceFilename);
  referenceReader->Update();

  vtkCleanPolyData *referenceCleaner = vtkCleanPolyData::New();
  referenceCleaner->SetInputData(referenceReader->GetOutput());
  referenceCleaner->Update();

  vtkPolyDataReader *targetReader = vtkPolyDataReader::New();
  targetReader->SetFileName(targetFilename);
  targetReader->Update();

  vtkCleanPolyData *targetCleaner = vtkCleanPolyData::New();
  targetCleaner->SetInputData(targetReader->GetOutput());
  targetCleaner->Update();

  // Initialize multithreading.
  if( maxNumberOfThreads > 0 )
  {
    icnsImageThreads::SetGlobalMaxThreads( maxNumberOfThreads );
    itk::MultiThreader::SetGlobalMaximumNumberOfThreads( maxNumberOfThreads );
  }

  // Warning: target and source definition of VTK and IMI is not consistent!
  vtkPolyData *targetSurface = targetCleaner->GetOutput();
  vtkPolyData *referenceSurface = referenceCleaner->GetOutput();

  //////////////////////////////////////////////
  // Execute Pre-Registration.
  if( bPreRegistration )
  {
    std::cout << "Starting affine ICP pre-registration..." << std::endl;

    int maxNumberOfUsedICPPoints = 5000;
    int maxNumberOfICPIterations = 50;
    int numSourcePoints = targetSurface->GetNumberOfPoints();
    if (numSourcePoints > 1000000)
    {
      maxNumberOfUsedICPPoints = (int) (numSourcePoints * 0.01);
    }

    std::cout << "Using " << maxNumberOfUsedICPPoints << " points and "
        << maxNumberOfICPIterations << " iterations..." << std::endl;

    vtkSmartPointer<vtkIterativeClosestPointTransform> icpTransform =
        vtkSmartPointer<vtkIterativeClosestPointTransform>::New();

    // Set source and target.
    icpTransform->SetSource( targetSurface );
    icpTransform->SetTarget( referenceSurface );

    // Affine transformation.
    icpTransform->GetLandmarkTransform()->SetModeToAffine();

    // Match centroids first.
    icpTransform->StartByMatchingCentroidsOn();
    icpTransform->SetMaximumNumberOfLandmarks( maxNumberOfUsedICPPoints );
    icpTransform->SetMaximumNumberOfIterations( maxNumberOfICPIterations );

    // Check for mean distance.
    icpTransform->CheckMeanDistanceOn();
    icpTransform->SetMaximumMeanDistance( 0.01 );
    icpTransform->SetMeanDistanceModeToRMS();

    // Execute ICP.
    icpTransform->Update();

    std::cout << "ICP: " << icpTransform->GetNumberOfIterations() << " Iterations, "
        << icpTransform->GetMeanDistance() << " Distance between last two iterations." << std::endl;


    // Apply calculated transformation.
    vtkTransformPolyDataFilter *transformer = vtkTransformPolyDataFilter::New();

    transformer->SetInputData( targetSurface );
    transformer->SetTransform( icpTransform );
    transformer->Update();

    targetSurface = transformer->GetOutput();
  }

  std::cout << "Instantiating matcher..." << std::endl;
  imiSurfaceConstrainedDiffusionRegistrationFilter *matcher;

  if( bSymmetric )
  {
    matcher = imiSymmetricSurfaceConstrainedDiffusionRegistrationFilter::New();
  }
  else
  {
    matcher = imiSurfaceConstrainedDiffusionRegistrationFilter::New();
  }
  matcher->SetTargetSurface( targetSurface );
  matcher->SetReferenceSurface( referenceSurface );
  matcher->SetNumberOfIterations( numberOfIterations );
  matcher->SetSmoothingSigma( sigma );
  matcher->SetUsePreComputedNeighborhoodLists( bPrecalculated );

  // Set directory for debug files.
  std::string stringFilename = static_cast<const char*>( outputFilename );
  std::string::size_type position = stringFilename.rfind( "/", stringFilename.length() );
  matcher->SetDebugPathName( stringFilename.substr( 0, position+1 ) );

  //////////////////////////////////////////////
  // Execute matcher
  std::cout << "Executing matcher..." << std::endl;
  if( !matcher->ExecuteRegistration() )
  {
    std::cerr << "Error while executing curvature matcher!" << std::endl;
    return EXIT_FAILURE;
  }

  if( outputFilename != NULL )
  {
    std::cout << "Writing deformed source to " << outputFilename << "..." << std::endl;
    vtkPolyDataWriter *writer = vtkPolyDataWriter::New();
    writer->SetInputData( matcher->GetTransformedTargetSurface() );
    writer->SetFileName( outputFilename );
    writer->Write();
  }

  std::cout << "imiSurfaceConstrainedDiffusion FINISHED!" << std::endl;
  std::cout << "==========================================\n\n" << std::endl;

  return EXIT_SUCCESS;
}
