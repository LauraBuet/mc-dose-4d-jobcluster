/** \file imiMLRMotionPredictionMethods.cpp
 *
 *  \b Initial \b Author: Matthias Wilms, Rene Werner \n\n
 *  \b Copyright (C) 2012 Institute of Medical Informatics,
 *     University of Luebeck
 *
 *  <!----------------------------------------------------------------------->
 *  <!--  Version Information  (generated by CVS, do not change manually)  -->
 *  $Id$
 *  $Log$
 *
 ****************************************************************************/

// Project includes
#include "imiMLRMotionPrediction.h"

namespace imi
{

// ----------------------------
//   Constructor / Destructor
// ----------------------------

imiMLRMotionPrediction* imiMLRMotionPrediction::New()
{
  return new imiMLRMotionPrediction();
}

imiMLRMotionPrediction::imiMLRMotionPrediction()
{
  // Set default parameters:
  m_multicollinearityCheckFlag = false;
  m_TikhonovRegularizationParameter = 0.001;
  m_squareMatrixPInv.clear();
  m_invSquareMatrixPInv.clear();
}

// imiMLRMotionPredictionMethods::~imiMLRMotionPredictionMethods()
imiMLRMotionPrediction::~imiMLRMotionPrediction()
{
}

// ----------------------------
//   Public methods
// ----------------------------

// imiMLRMotionPredictionMethods::TrainLSEstimator
bool imiMLRMotionPrediction::TrainLSEstimator( void )
{
  imiDEBUGINFO( 5, "-----------------------------------" );
  imiDEBUGINFO( 5, "  TRAINING OF LS ESTIMATOR" );
  imiDEBUGINFO( 5, "-----------------------------------" );

  //-------------------------------------------
  // FIRST STEP:
  // Center regressor data
  //-------------------------------------------

  if( m_centeredRegressorMatrix.empty() )
  {
    imiERROR( "MLR: Regressor matrix empty! Aborting computation." );
    return false;
  }

  //-------------------------------------------
  // First STEP:
  // Center observation data
  //-------------------------------------------


  if( m_centeredObservationMatrix.empty() )
  {
    imiERROR( "MLR: Observation matrix empty! Aborting computation." );
    return false;
  }


  //-------------------------------------------
  // Center regressor data
  //-------------------------------------------




  //std::cout<<"m_centeredRegressorMatrix: "<<m_centeredRegressorMatrix<<std::endl;

  //-------------------------------------------
  // Second STEP:
  // Compute square matrix
  //-------------------------------------------

  imiDEBUGINFO( 5, "  Computing square matrix for pseudoinverse ... " );

    if (m_centeredRegressorMatrix.rows() <= m_centeredRegressorMatrix.cols())
    {
        m_squareMatrixPInv=m_centeredRegressorMatrix*m_centeredRegressorMatrix.transpose();
    } else {
        m_squareMatrixPInv=m_centeredRegressorMatrix.transpose()*m_centeredRegressorMatrix;
    }


/*std::cout<<"    m_centeredRegressorMatrix"<<    m_centeredRegressorMatrix<<std::endl;
    std::cout<<"m_squareMatrixPInv"<<m_squareMatrixPInv<<std::endl;*/

  return true;
}

// imiMLRMotionPredictionMethods::CheckForMultiCollinearities
bool imiMLRMotionPrediction::MulticollinearityCheck( VnlMatrixType& testMatrix )
{
  imiDEBUGINFO( 5, "  Checking matrix properties ... " )
  MatrixValueType conditionNumber = 0.0;

  // Preparation: Obviously, vnl rank works only for double matrices ...
  vnl_matrix<double> testMatrix_double( testMatrix.rows(), testMatrix.cols() );
  for( unsigned int i = 0; i < testMatrix.rows(); i++ )
  {
    for( unsigned int j = 0; j < testMatrix.cols(); j++ )
    {
      testMatrix_double[i][j] = static_cast<double>( testMatrix[i][j] );
    }
  }

  // FIRST TEST: Compute rank of covariance matrix.
  // If rank is not full, the matrix is (in principle) not invertible.
  // Thus, a workaround is required.

  imiDEBUGINFO( 5, "Dimension of matrix: " << testMatrix.rows() );
  unsigned int covMatrixRank = vnl_rank( testMatrix_double );
  imiDEBUGINFO( 5, "Rank of tested matrix: " << covMatrixRank );
  if( covMatrixRank < testMatrix.rows() )
  {
    conditionNumber = -1.0;
    imiWARNING( "Rank of tested matrix smaller than dimension." );
  }

  // SECOND TEST: Compute eigensystem and condition number of covariance matrix.
  // The condition number is defined as sqrt of the ratio of the largest and the smallest
  // eigenvalue of the covariance matrix. A number larger than 30 is usually assumed to
  // indicate multicollinearities (high correlation between at least two regressor variables).

  if( conditionNumber != -1.0 )
  {
    imiDEBUGINFO( 5, "Computing eigensystem: " << std::endl );
    vnl_symmetric_eigensystem<MatrixValueType> eigSystem( testMatrix );
    int testValue = 0;
    for( unsigned int i = 0; i < testMatrix.rows(); i++ )
    {
      vcl_cerr << "  " << i << "-th eigenvalue: " << eigSystem.get_eigenvalue( i ) << " (" << eigSystem.get_eigenvector( i ) << ")" << std::endl;
      if( eigSystem.get_eigenvalue( i ) < 0 )
      {
        testValue++;
      }
    }

    conditionNumber = sqrt( fabs( eigSystem.get_eigenvalue( testMatrix.rows() - 1 ) ) / fabs( eigSystem.get_eigenvalue( 0 ) ) );
    vcl_cerr << "  --> Condition number: " << conditionNumber << std::endl;

    if( conditionNumber > 30 )
    {
      imiWARNING( "Condition number > 30." );
    }
    else
    {
      imiDEBUGINFO( 5, "No multicollinearities in tested matrix!" )
      return true;
    }
  }

  // WORKAROUND in case of multicollinearities:
  // Tikhonov regularisation, i.e. AA^T --> AA^T + \lambda*E_n
  // Here we attempt to reduce the condition number to < 30 in an iterative manner.

  imiDEBUGINFO( 5, "Performing Tikhonov regularization!" );
  MatrixValueType finalTikhonovRegularizationParameter = 0.0;

  //conditionNumber=1;

  while( (conditionNumber > 30))
  {

    //--------------------------------------------------------------------------
    //code max: for more than 500 input points -> due to performance reasons
    //          the eigensystem of the covariance matrix no longer gets checked,
    //          simply adding of 0.2 as regularization parameter

    if( testMatrix.rows() > 500 )
    {
      finalTikhonovRegularizationParameter = 0.2;
      VnlMatrixType regularizingMatrix( testMatrix.rows(), testMatrix.cols() );
      regularizingMatrix.fill( 0.0 );
      regularizingMatrix.fill_diagonal( finalTikhonovRegularizationParameter );
      testMatrix = testMatrix + regularizingMatrix;

      std::cout << " Reg-param set to 0.2 ... " << std::endl;
      std::cout << " Aborting regularization!" << std::endl;
      break;
    }

    //--------------------------------------------------------------------------

    finalTikhonovRegularizationParameter += m_TikhonovRegularizationParameter;

    VnlMatrixType regularizingMatrix( testMatrix.rows(), testMatrix.cols() );
    regularizingMatrix.fill( 0.0 );
    regularizingMatrix.fill_diagonal( m_TikhonovRegularizationParameter );

    testMatrix = testMatrix + regularizingMatrix;

    // Again: computing eigensystem and condition number of updated covariance matrix:
    vnl_symmetric_eigensystem<MatrixValueType> eigSystem( testMatrix );
    conditionNumber = sqrt( fabs( eigSystem.get_eigenvalue( testMatrix.rows() - 1 ) ) / fabs( eigSystem.get_eigenvalue( 0 ) ) );

    if( finalTikhonovRegularizationParameter >= 1.0 )
    {
      std::cout << " Reg-param reached 1.0 ... " << std::endl;
      std::cout << " Condition number: " << conditionNumber << std::endl;
      std::cout << " Aborting regularization!" << std::endl;
      break;
    }
    imiINFO( "  Tikhonov regularization factor: " << finalTikhonovRegularizationParameter << "; condition number: " << conditionNumber );
  }
  vcl_cerr << "  --> Final Tikhonov regularization parameter: " << finalTikhonovRegularizationParameter << std::endl;
  return true;
}

// imiMLRMotionPredictionMethods::PredictOutput
bool imiMLRMotionPrediction::PredictOutput( VnlMatrixType& regressorMeasurement, VnlMatrixType& predictedOutput )
{
  imiDEBUGINFO( 5, "  Predicting output for given regressor measurement ... " );

  if( m_invSquareMatrixPInv.empty() )
  {

    if (m_multicollinearityCheckFlag)
    {
      MulticollinearityCheck(m_squareMatrixPInv);
    } else {
      imiINFO( "Ridge parameter: "<<m_TikhonovRegularizationParameter );
      VnlMatrixType regularizingMatrix( m_squareMatrixPInv.rows(), m_squareMatrixPInv.cols() );
      regularizingMatrix.fill( 0.0 );
      regularizingMatrix.fill_diagonal( m_TikhonovRegularizationParameter );
      m_squareMatrixPInv = m_squareMatrixPInv + regularizingMatrix;

    }

    m_invSquareMatrixPInv = vnl_matrix_inverse<MatrixValueType>( m_squareMatrixPInv );

  }
  imiINFO( "inversion" );

  if (m_trainedEstimator.empty())
  {

    if (m_centeredRegressorMatrix.rows() <= m_centeredRegressorMatrix.cols())
    {
        predictedOutput = m_meanObservationVector + (m_centeredObservationMatrix * (m_centeredRegressorMatrix.transpose() * (m_invSquareMatrixPInv * (regressorMeasurement-m_meanRegressorVector))));
    } else {
        predictedOutput = m_meanObservationVector + ((m_centeredObservationMatrix * m_invSquareMatrixPInv) * (m_centeredRegressorMatrix.transpose()* (regressorMeasurement-m_meanRegressorVector)));
    }

  } else
  {
    predictedOutput = m_meanObservationVector + (m_trainedEstimator * (regressorMeasurement-m_meanRegressorVector));
  }

  imiDEBUGINFO( 5, "  finished."<<std::endl );
  return true;
}

// ----------------------------
//   Protected / Private methods
// ----------------------------

}// namespace imi
